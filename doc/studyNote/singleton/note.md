#单例（Singleton）
+ 构造方法私有化
+ 在类的内部创建实例化对象
+ 对外开放public static方法取得实例

###饿汉式单例
+ 类加载时就创建实例（无论调用与否都创建）

    ####优点
    + 绝对线程安全
    + 访问效率较高
    ####缺点
    + 浪费内存空间


###懒汉式单例（simple，static）
+ 初次调用时创建实例

    ####优点
    + 因被调用时才创建实例，所以相对节省内存空间
    ####缺点
    + 线程不安全。不同线程同时取得实例的时候，可能创建多个不同的实例
    + 加了synchronized关键字能够保证线程安全，但在线程数较多的情况下性能下降
    
 
 ###懒汉式单例（double check）
 + 用同步代码块创建实例
 + 由于使用同步代码块，所以锁住的不是整个类，而是getInstance()方法
 + 在进入同步代码块之前和进入同步代码块之后分别进行实例是否为null的判断
 + 但是，既然使用到了synchronized关键字，总归是要上锁，性能问题残留
 
  ###懒汉式单例（Inner Class）
 + 通过内部类创建单实例
 + 解决了线程安全问题
 + 内部类只在调用内部类本身时才加载
 + 但仍然可以被反射共计
   + 可以在构造方法里判断内部类的实例是否为空，当不为空时抛出异常，防止利用反射创建多个实例
   
   
  ###攻击单例方法
 + 通过反射攻击
   + 在单例的私有构造方法中加入INSTANCE是否为空的判断，来防止通过反射攻击
 
 + 通过序列化攻击
   + 把单例对象通过序列化写入磁盘，再反序列化为内存对象。这是反序列化的对象后的对象会重新分配内存，生成不同的实例
   + 但单例的类必须实现Serializable接口
   + 可以加入readResolve()方法来防止通过序列化破坏单例
 
 ###注册式单例（推荐）
 + 枚举式单例
   + 不能通过序列化破坏单例。
   + 不能通过反射破坏单例 
 
 
 + 容器缓存
   + 线程不安全，需要synchronized关键字来保证容器（map）的线程安全
   
 
 ###ThreadLocal
 + 一个线程内部保证单例
 + 有N个线程就有N个实例